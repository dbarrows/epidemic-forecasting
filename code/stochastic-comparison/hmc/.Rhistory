source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
install.packages("deSOlve")
install.packages("deSolve")
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
??out
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
theta = seq(from=1/(N+1), to = N/(N+1), length=10)
theta
N
1/501
N = 10
theta = seq(from=1/(N+1), to = N/(N+1), length=10)
theta
pTheta = pmin(theta, 1-theta)
pTheta
pTheta = pTheta/sum(pTheta)
pTheta
pDataGivenTheta = choose(N, nTexting) * theta^nTexting * (1-theta)^nNot
source('C:/Users/Dexter/Dropbox/Rstan_stuff/sir_stan.r', echo=TRUE)
install.packages(c("jsonlite", "mime", "packrat", "Rcpp", "RcppEigen", "rmarkdown", "rstudioapi", "scales", "shinyjs", "shinystan", "stringi", "xtable"))
R.version()
R.Version()
library(deSolve)
library(rstan)
library(shinystan)
library(ggplot2)
library(RColorBrewer)
library(reshape2)
library(gridExtra)
# NOTE: to save plots, uncomment the ggsave lines
SIR <- function(Time, State, Pars) {
with(as.list(c(State, Pars)), {
B   <- R0*r/N
BSI <- B*S*I
rI  <- r*I
dS = -BSI
dI = BSI - rI
dR = rI
return(list(c(dS, dI, dR)))
})
}
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B0) + eta*(log(B) - log(B0)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
set.seed(1001)
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- 25
pars <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
gam = 2, 		# new infected shock intensity
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout <- StocSIR(true_init_cond, pars, T, steps)
colnames(sdeout) <- c('S','I','R','B')
infec_counts_raw <- sdeout[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
plotdata <- data.frame(times = 0:T, true = sdeout[,'I'], data = datapart)
g <- ggplot(plotdata, aes(times)) +
geom_line(aes(y = true, colour = "True")) +
geom_point(aes(y = data, colour = "Data")) +
labs(x = "Time", y = "Infection count", color = "") +
scale_color_brewer(palette="Paired") +
theme(panel.background = element_rect(fill = "#F0F0F0"))
quartz()
print(g)
#ggsave(g, filename="dataplot.pdf", height=4, width=6.5)
datlen <- T*7 + 1
data <- matrix(data = -1, nrow = T+1, ncol = steps)
data[,1] <- infec_counts
standata <- as.vector(t(data))[1:datlen]
sir_data <- list( T = datlen,   	# simulation time
y = standata, 	# infection count data
N = 500,      	# population size
h = 1/steps )   	# step size per day
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
stan_options <- list(   chains = 1,    		# number of chains
iter   = 5000, 		# iterations per chain
warmup = 1000, 		# warmup interations
thin   = 10,   		# thinning number
verbose = TRUE,
refresh = 50)
setwd("C:/Users/Dexter/Drive/McMaster/Current/Thesis/code/stochastic-comparison/hmc")
library(deSolve)
library(rstan)
library(shinystan)
library(ggplot2)
library(RColorBrewer)
library(reshape2)
library(gridExtra)
# NOTE: to save plots, uncomment the ggsave lines
SIR <- function(Time, State, Pars) {
with(as.list(c(State, Pars)), {
B   <- R0*r/N
BSI <- B*S*I
rI  <- r*I
dS = -BSI
dI = BSI - rI
dR = rI
return(list(c(dS, dI, dR)))
})
}
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B0) + eta*(log(B) - log(B0)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
set.seed(1001)
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- 25
pars <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
gam = 2, 		# new infected shock intensity
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout <- StocSIR(true_init_cond, pars, T, steps)
colnames(sdeout) <- c('S','I','R','B')
infec_counts_raw <- sdeout[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
plotdata <- data.frame(times = 0:T, true = sdeout[,'I'], data = datapart)
g <- ggplot(plotdata, aes(times)) +
geom_line(aes(y = true, colour = "True")) +
geom_point(aes(y = data, colour = "Data")) +
labs(x = "Time", y = "Infection count", color = "") +
scale_color_brewer(palette="Paired") +
theme(panel.background = element_rect(fill = "#F0F0F0"))
quartz()
print(g)
#ggsave(g, filename="dataplot.pdf", height=4, width=6.5)
datlen <- T*7 + 1
data <- matrix(data = -1, nrow = T+1, ncol = steps)
data[,1] <- infec_counts
standata <- as.vector(t(data))[1:datlen]
sir_data <- list( T = datlen,   	# simulation time
y = standata, 	# infection count data
N = 500,      	# population size
h = 1/steps )   	# step size per day
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
stan_options <- list(   chains = 1,    		# number of chains
iter   = 5000, 		# iterations per chain
warmup = 1000, 		# warmup interations
thin   = 10,   		# thinning number
verbose = TRUE,
refresh = 50)
install.packages("rstan")
library(deSolve)
library(rstan)
library(shinystan)
library(ggplot2)
library(RColorBrewer)
library(reshape2)
library(gridExtra)
# NOTE: to save plots, uncomment the ggsave lines
SIR <- function(Time, State, Pars) {
with(as.list(c(State, Pars)), {
B   <- R0*r/N
BSI <- B*S*I
rI  <- r*I
dS = -BSI
dI = BSI - rI
dR = rI
return(list(c(dS, dI, dR)))
})
}
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B0) + eta*(log(B) - log(B0)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
set.seed(1001)
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- 25
pars <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
gam = 2, 		# new infected shock intensity
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout <- StocSIR(true_init_cond, pars, T, steps)
colnames(sdeout) <- c('S','I','R','B')
infec_counts_raw <- sdeout[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
plotdata <- data.frame(times = 0:T, true = sdeout[,'I'], data = datapart)
g <- ggplot(plotdata, aes(times)) +
geom_line(aes(y = true, colour = "True")) +
geom_point(aes(y = data, colour = "Data")) +
labs(x = "Time", y = "Infection count", color = "") +
scale_color_brewer(palette="Paired") +
theme(panel.background = element_rect(fill = "#F0F0F0"))
quartz()
print(g)
#ggsave(g, filename="dataplot.pdf", height=4, width=6.5)
datlen <- T*7 + 1
data <- matrix(data = -1, nrow = T+1, ncol = steps)
data[,1] <- infec_counts
standata <- as.vector(t(data))[1:datlen]
sir_data <- list( T = datlen,   	# simulation time
y = standata, 	# infection count data
N = 500,      	# population size
h = 1/steps )   	# step size per day
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
stan_options <- list(   chains = 1,    		# number of chains
iter   = 5000, 		# iterations per chain
warmup = 1000, 		# warmup interations
thin   = 10,   		# thinning number
verbose = TRUE,
refresh = 50)
fit <- with(stan_options,
stan(file  	= "sirode_euler.stan",
data    = sir_data,
chains  = chains,
iter    = iter,
warmup  = warmup,
thin    = thin,
verbose = verbose,
refresh = refresh )
)
