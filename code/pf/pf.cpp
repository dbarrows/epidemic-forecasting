/*	Author: Dexter Barrows
	Github: dbarrows.github.io
	*/

/*	Runs a particle filter on synthetic noisy data and attempts to
	reconstruct underlying true state at each time step. Note that
	this program uses gnuplot to plot the data, so an x11
	environment must be present.

	Also, the accompanying "pf.plg" file contains the instructions
	gnuplot will use. It must be present in the same directory as
	the executable generated by compiling this file.
	
	Compile with:

	g++ -O2 pf.cpp -o pf

	*/

#include <stdio.h> 
#include <math.h>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <string>

#include "rand.h"
#include "timer.h"

//#define NP 		70000 		// number of particles per block
#define T 		100			// time to simulate over
#define R0true 	3.0			// infectiousness
#define rtrue 	1e-1		// recovery rate
#define N 		500.0 		// population size
#define merr 	5.0  		// expected measurement error

struct Particle {
	float R0;
	float r;
	float sigma;
	float S;
	float I;
	float R;
	float Sinit;
	float Iinit;
	float Rinit;
};

int timeval_subtract (double *result, struct timeval *x, struct timeval *y);
int check_float(float x,float y);
void exp_euler_SIR(float h, float t0, float tn, Particle * particle);
void copyParticle(Particle * dst, Particle * src);
bool isCollapsed(Particle * particles, int NP);

int main(int argc, char *argv[]) {

	float i_infec = 5;

	int NP = 50000;

	srand(time(NULL));								// Seed PRNG with system time

	Particle particle_true;
	particle_true.R0 	= R0true;
	particle_true.r  	= rtrue;
	particle_true.sigma = merr;
	particle_true.S  	= N - i_infec;
	particle_true.I  	= i_infec;
	particle_true.R  	= 0;


	printf("System parameters\n");
	printf("-----------------\n");
	printf("R0:    %f\n", R0true);
	printf("r:     %f\n", rtrue);
	printf("merr:  %f\n", merr);

	float y_true[T];	// true number of infected peeps
	float y_noise[T];	// true number of infected peeps with observation noise
	float y_est[T]; 	// particle mean state estimation

	float y_par_noise; 	// particle estimates with noise
	float w[NP]; 		// particle weights

	float Neff[T]; 		// number of effective particles at each step

	Particle particles[NP]; 	// particle estimates for current step
	Particle particles_old[NP]; // intermediate particle states for resampling

	int nTrials = 50;

	int iterCollapse[nTrials];

	// generate our true trajectory and noisy observation data
	y_true[0] = particle_true.I;
	y_noise[0] = y_true[0] +  merr*randn();
	if (y_noise[0] < 0)
		y_noise[0] = 0;
	for (int i = 1; i < T; i++) {
		exp_euler_SIR( 1.0/100, 0.0, 1.0, &particle_true);
		y_true[i] = particle_true.I;
		y_noise[i] = y_true[i] + merr*randn();
		if (y_noise[i] < 0)
			y_noise[i] = 0;
	}

	double restime;
	struct timeval  tdr0, tdr1;

	gettimeofday (&tdr0, NULL);

	int Tlim = T;

	// DO THE FILTER

	for (int trial = 1; trial < nTrials; trial++) {

		NP = 1000*trial;
		bool collapsed = false;

		printf("Starting trial %d\n", trial);

		printf("Initializing particle states\n");

		// initialize particle states
		for (int i = 0; i < NP; i++) {

			// initial SIR states
			float i_infec_par = i_infec + merr*randn();
			if (i_infec_par < 0)
				i_infec_par = 0;
			float i_sus_par = N - i_infec_par;
			particles[i].S = i_sus_par;
			particles[i].I = i_infec_par;
			particles[i].R = 0;
			particles[i].Sinit = i_sus_par;
			particles[i].Iinit = i_infec_par;
			particles[i].Rinit = 0;

			// fixed parameter values
			float R0can, rcan, sigmacan;

			do {
				R0can = R0true + R0true*randn();
			} while (R0can < 0);
			particles[i].R0 = R0can;

			do {
				rcan = rtrue + rtrue*randn();
			} while (rcan < 0);
			particles[i].r = rcan;

			do {
				sigmacan = merr + merr*randn();
				//sigmacan = merr;
			} while (sigmacan < 0);
			particles[i].sigma = sigmacan;

		}

		printf("Calculating initial estimate\n");

		Neff[0] = NP;

		// initial estimate
		y_est[0] = 0;
		for (int n = 0; n < NP; n++)
			y_est[0] += particles[n].I;
		y_est[0] /= NP;

		printf("Starting filter\n");

		for (int t = 1; t < Tlim; t++) {

			// can be done completely in parallel
			for (int n = 0; n < NP; n++) {

				exp_euler_SIR(1.0/100, 0.0, 1.0, &particles[n]);

				float merr_par = particles[n].sigma;

				y_par_noise = particles[n].I + (float) merr_par*randn();
				if (y_par_noise < 0)										
					y_par_noise = 0;

				float y_diff = y_noise[t] - y_par_noise;
				
				w[n] = 1.0/(merr*sqrt(2.0*M_PI)) * exp( - y_diff*y_diff / (2.0*merr*merr) );

			}

			// cumulative sum
			for (int n = 1; n < NP; n++) {
				w[n] += w[n-1];
			}

			float Neffsum = 0;
			for (int n = 0; n < NP; n++) {
				float curW;
				if (n == 0)
					curW = w[0] / w[NP-1];
				else
					curW = (w[n] - w[n-1]) / w[NP-1];
				Neffsum += curW*curW;
			}
			Neff[t] = 1 / Neffsum;

			if (!collapsed) {
				if ( isCollapsed(particles, NP) ) {
					iterCollapse[trial] = t;
					collapsed = true;
				}
			}


			// save particle states to resample from
			for (int n = 0; n < NP; n++){
				copyParticle(&particles_old[n], &particles[n]);
			}

			// resampling
			for (int n = 0; n < NP; n++) {

				float w_r = randu() * w[NP-1];
				int i = 0;
				while (w_r >= w[i]) {
					i++;
				}

				// i is now the index to copy state from
				copyParticle(&particles[n], &particles_old[i]);

			}

			// produce estimate
			y_est[t] = 0;
			for (int n = 0; n < NP; n++)
				y_est[t] += particles[n].I;
			y_est[t] /= NP;

		}

		if (!collapsed)
			iterCollapse[trial] = T;

	}

	gettimeofday (&tdr1, NULL);
    timeval_subtract (&restime, &tdr1, &tdr0);
    printf ("Single threaded runtime %e\n", restime);

    // Print Neff info

    for (int t = 1; t < Tlim; t++)
    	printf("%d %f\n", t, Neff[t]);

    // Get parameter estimates

    float 	R0mean = 0,
    		rmean = 0,
    		sigmamean = 0,
    		Sinitmean = 0,
    		Iinitmean = 0,
    		Rinitmean = 0;

    // means

    for (int n = 0; n < NP; n++) {

    	R0mean += particles[n].R0;
    	rmean += particles[n].r;
    	sigmamean += particles[n].sigma;
    	Sinitmean += particles[n].Sinit;
    	Iinitmean += particles[n].Iinit;
    	Rinitmean += particles[n].Rinit;

    }

    R0mean 		/= NP;
    rmean 		/= NP;
    sigmamean 	/= NP;
    Sinitmean 	/= NP;
    Iinitmean 	/= NP;
    Rinitmean 	/= NP;

    // standard deviations

    float 	R0sd = 0,
    		rsd = 0,
    		sigmasd = 0,
    		Sinitsd = 0,
    		Iinitsd = 0,
    		Rinitsd = 0;

    for (int n = 0; n < NP; n++) {

    	R0sd 	+= ( particles[n].R0 - R0mean ) * ( particles[n].R0 - R0mean );
    	rsd 	+= ( particles[n].r - rmean ) * ( particles[n].r - rmean );
    	sigmasd += ( particles[n].sigma - sigmamean ) * ( particles[n].sigma - sigmamean );
    	Sinitsd += ( particles[n].Sinit - Sinitmean ) * ( particles[n].Sinit - Sinitmean );
    	Iinitsd += ( particles[n].Iinit - Iinitmean ) * ( particles[n].Iinit - Iinitmean );
    	Rinitsd += ( particles[n].Rinit - Rinitmean ) * ( particles[n].Rinit - Rinitmean );

    }

    R0sd 		/= NP;
    rsd 		/= NP;
    sigmasd 	/= NP;
    Sinitsd 	/= NP;
    Iinitsd 	/= NP;
    Rinitsd 	/= NP;

    printf("Parameter estimates (mean | sd)\n");
	printf("-------------------------------\n");
	printf("R0:      %f %f\n", R0mean, R0sd);
	printf("r:       %f %f\n", rmean, rsd);
	printf("sigma:   %f %f\n", sigmamean, sigmasd);
	printf("S_init:  %f %f\n", Sinitmean, Sinitsd);
	printf("I_init:  %f %f\n", Iinitmean, Iinitsd);
	printf("R_init:  %f %f\n", Rinitmean, Rinitsd);


	// print collapse statistics

	for (int trial = 0; trial < nTrials; trial++)
		printf("Trial %d collapse: %d\n", trial, iterCollapse[trial]);

	// Save collapse statistics

	std::string collapsefile("collapsedata.dat");

    printf("Writing parameter results to file '%s'...\n", collapsefile.c_str());

	FILE * collapseout = fopen(collapsefile.c_str(), "w");

	for (int trial = 0; trial < nTrials; trial++)
		fprintf(collapseout, "%d %d\n", trial, iterCollapse[trial]);

	fclose(collapseout);	

	// Save results for post-processing

	std::string paramfile("pfdata.dat");

    printf("Writing parameter results to file '%s'...\n", paramfile.c_str());

	FILE * pfout = fopen(paramfile.c_str(), "w");

	for (int n = 0; n < NP; n++) {
		fprintf(pfout, "%f ", particles[n].R0);
		fprintf(pfout, "%f ", particles[n].r);
		fprintf(pfout, "%f ", particles[n].sigma);
		fprintf(pfout, "%f ", particles[n].Sinit);
		fprintf(pfout, "%f ", particles[n].Iinit);
		fprintf(pfout, "%f\n", particles[n].Rinit);
	}

	fclose(pfout);	


	// Save results for plotting

    std::string datafile("plotdata.dat");

    printf("Writing plotting results to file '%s'...\n", datafile.c_str());

	FILE * paramout = fopen(datafile.c_str(), "w");

	for (int t = 0; t < T; t++) {
		fprintf(paramout, "%d ", t);
		fprintf(paramout, "%f ", y_true[t]);
		fprintf(paramout, "%f ", y_noise[t]);
		fprintf(paramout, "%f\n", y_est[t]);
	}

	fclose(paramout);

	printf("Plotting using gnuplot...\n");
	printf("Press ENTER close plot and continue\n");

	std::string syscall("gnuplot -e \"filename='");
	syscall += datafile;
	syscall += "'\" pf.plg";

	system( syscall.c_str() );

}


/*	Use the Explicit Euler integration scheme to integrate SIR model forward in time
	float h 	- time step size
	float t0 	- start time
	float tn 	- stop time
	float * y 	- current system state; a three-component vector representing [S I R], susceptible-infected-recovered
	*/
void exp_euler_SIR(float h, float t0, float tn, Particle * particle) {
	
	float t = t0;

	int num_steps = floor( (tn-t0) / h );

	float S = particle->S;
	float I = particle->I;
	float R = particle->R;

	float R0 	= particle->R0;
	float r 	= particle->r;
	float B 	= R0 * r / N;

	for(int i = 0; i < num_steps; i++) {
		// get derivatives
		float dS = - B*S*I;
		float dI = B*S*I - r*I;
		float dR = r*I;
		// step forward by h
		S += h*dS;
		I += h*dI;
		R += h*dR;
	}

	particle->S = S;
	particle->I = I;
	particle->R = R;

}

bool isCollapsed(Particle * particles, int NP) {

	bool retVal;

	float R0mean = 0, rmean = 0, sigmamean = 0, Sinitmean = 0, Iinitmean = 0, Rinitmean = 0;

    // means

    for (int n = 0; n < NP; n++) {

    	R0mean += particles[n].R0;
    	rmean += particles[n].r;
    	sigmamean += particles[n].sigma;
    	Sinitmean += particles[n].Sinit;
    	Iinitmean += particles[n].Iinit;
    	Rinitmean += particles[n].Rinit;

    }

    R0mean 		/= NP;
    rmean 		/= NP;
    sigmamean 	/= NP;
    Sinitmean 	/= NP;
    Iinitmean 	/= NP;
    Rinitmean 	/= NP;

	float 	R0sd = 0, rsd = 0, sigmasd = 0, Sinitsd = 0, Iinitsd = 0, Rinitsd = 0;

    for (int n = 0; n < NP; n++) {

    	R0sd 	+= ( particles[n].R0 - R0mean ) * ( particles[n].R0 - R0mean );
    	rsd 	+= ( particles[n].r - rmean ) * ( particles[n].r - rmean );
    	sigmasd += ( particles[n].sigma - sigmamean ) * ( particles[n].sigma - sigmamean );
    	Sinitsd += ( particles[n].Sinit - Sinitmean ) * ( particles[n].Sinit - Sinitmean );
    	Iinitsd += ( particles[n].Iinit - Iinitmean ) * ( particles[n].Iinit - Iinitmean );
    	Rinitsd += ( particles[n].Rinit - Rinitmean ) * ( particles[n].Rinit - Rinitmean );

    }

    R0sd 		/= NP;
    rsd 		/= NP;
    sigmasd 	/= NP;
    Sinitsd 	/= NP;
    Iinitsd 	/= NP;
    Rinitsd 	/= NP;

    if ( (R0sd + rsd + sigmasd) < 1e-5)
    	retVal = true;
    else
    	retVal = false;

    return retVal;

}

void copyParticle(Particle * dst, Particle * src) {

	dst->R0 	= src->R0;
	dst->r 		= src->r;
	dst->sigma 	= src->sigma;
	dst->S 		= src->S;
	dst->I 		= src->I;
	dst->R 		= src->I;
	dst->Sinit  = src->Sinit;
	dst->Iinit  = src->Iinit;
	dst->Rinit  = src->Rinit;

}