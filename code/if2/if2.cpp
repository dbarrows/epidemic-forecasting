/*	Author: Dexter Barrows
	Github: dbarrows.github.io
	*/

/*	Runs a particle filter on synthetic noisy data and attempts to
	reconstruct underlying true state at each time step. Note that
	this program uses gnuplot to plot the data, so an x11
	environment must be present.

	Also, the accompanying "pf.plg" file contains the instructions
	gnuplot will use. It must be present in the same directory as
	the executable generated by compiling this file.

	*/

#include <stdio.h> 
#include <math.h>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <string>

#include "rand.h"
#include "timer.h"

#define T 		100			// time to simulate over
#define R0true 	3.0			// infectiousness
#define rtrue 	1e-1		// recovery rate
#define N 		500.0 		// population size
#define merr 	5.0  		// expected measurement error


struct Particle {
	float R0;
	float r;
	float sigma;
	float S;
	float I;
	float R;
	float Sinit;
	float Iinit;
	float Rinit;
};


int timeval_subtract (double *result, struct timeval *x, struct timeval *y);
int check_float(float x,float y);
void exp_euler_SIR(float h, float t0, float tn, Particle * particle);
void copyParticle(Particle * dst, Particle * src);
void perturbParticles(Particle * particles, int NP, int passnum);
bool isCollapsed(Particle * particles, int NP);


int main(int argc, char *argv[]) {

	float i_infec = 5;

	int NP = 5000;

	srand(time(NULL));								// Seed PRNG with system time

	Particle particle_true;
	particle_true.R0 	= R0true;
	particle_true.r  	= rtrue;
	particle_true.sigma = merr;
	particle_true.S  	= N - i_infec;
	particle_true.I  	= i_infec;
	particle_true.R  	= 0;


	printf("System parameters\n");
	printf("-----------------\n");
	printf("R0:    %f\n", R0true);
	printf("r:     %f\n", rtrue);
	printf("merr:  %f\n", merr);

	float y_true[T];	// true number of infected peeps
	float y_noise[T];	// true number of infected peeps with observation noise
	float y_est[T]; 	// particle mean state estimation

	float y_par_noise; 	// particle estimates with noise
	float w[NP]; 		// particle weights

	Particle particles[NP]; 	// particle estimates for current step
	Particle particles_old[NP]; // intermediate particle states for resampling

	// generate our true trajectory and noisy observation data
	y_true[0] = particle_true.I;
	y_noise[0] = y_true[0] +  merr*randn();
	if (y_noise[0] < 0)
		y_noise[0] = 0;
	for (int i = 1; i < T; i++) {
		exp_euler_SIR( 1.0/100, 0.0, 1.0, &particle_true);
		y_true[i] = particle_true.I;
		y_noise[i] = y_true[i] + merr*randn();
		if (y_noise[i] < 0)
			y_noise[i] = 0;
	}

	double restime;
	struct timeval  tdr0, tdr1;

	gettimeofday (&tdr0, NULL);

	int Tlim = T;

	printf("Initializing particle states\n");

	// initialize particle parameter states
	for (int i = 0; i < NP; i++) {

		// initial parameter values
		float R0can, rcan, sigmacan;

		do {
			R0can = R0true + R0true*randn();
		} while (R0can < 0);
		particles[i].R0 = R0can;

		do {
			rcan = rtrue + rtrue*randn();
		} while (rcan < 0);
		particles[i].r = rcan;

		do {
			sigmacan = merr + merr*randn();
			//sigmacan = merr;
		} while (sigmacan < 0);
		particles[i].sigma = sigmacan;

	}

	// START PASSES THROUGH DATA

	int nPasses = 10;

	printf("Starting filter\n");

	for (int pass = 0; pass < nPasses; pass++) {

		printf("Pass %d\n", pass);

		// initialize particle system states
		for (int n = 0; n < NP; n++) {

			// initial SIR states
			float i_infec_par = i_infec + merr*randn();
			if (i_infec_par < 0)
				i_infec_par = 0;
			float i_sus_par = N - i_infec_par;
			particles[n].S = i_sus_par;
			particles[n].I = i_infec_par;
			particles[n].R = 0;
			particles[n].Sinit = i_sus_par;
			particles[n].Iinit = i_infec_par;
			particles[n].Rinit = 0.0;

		}

		// initial estimate
		y_est[0] = 0;
		for (int n = 0; n < NP; n++)
			y_est[0] += particles[n].I;
		y_est[0] /= NP;

		// between-pass perturbations
		perturbParticles(particles, NP, pass);

		for (int t = 1; t < Tlim; t++) {

			// between-iteration perturbations
			perturbParticles(particles, NP, pass);

			// generate individual predictions and weight
			for (int n = 0; n < NP; n++) {

				exp_euler_SIR(1.0/100, 0.0, 1.0, &particles[n]);

				float merr_par = particles[n].sigma;

				y_par_noise = particles[n].I + (float) merr_par*randn();
				if (y_par_noise < 0)										
					y_par_noise = 0;

				float y_diff = y_noise[t] - y_par_noise;
				
				w[n] = 1.0/(merr_par*sqrt(2.0*M_PI)) * exp( - y_diff*y_diff / (2.0*merr_par*merr_par) );

			}

			// cumulative sum
			for (int n = 1; n < NP; n++) {
				w[n] += w[n-1];
			}

			// save particle states to resample from
			for (int n = 0; n < NP; n++){
				copyParticle(&particles_old[n], &particles[n]);
			}

			// resampling
			for (int n = 0; n < NP; n++) {

				float w_r = randu() * w[NP-1];
				int i = 0;
				while (w_r >= w[i]) {
					i++;
				}

				// i is now the index to copy state from
				copyParticle(&particles[n], &particles_old[i]);

			}

			// produce estimate
			y_est[t] = 0;
			for (int n = 0; n < NP; n++)
				y_est[t] += particles[n].I;
			y_est[t] /= NP;

		}

	}

	gettimeofday (&tdr1, NULL);
    timeval_subtract (&restime, &tdr1, &tdr0);
    printf ("Single threaded runtime %e\n", restime);

    // Get parameter estimates

    float 	R0mean = 0,
    		rmean = 0,
    		sigmamean = 0,
    		Sinitmean = 0,
    		Iinitmean = 0,
    		Rinitmean = 0;

    // means

    for (int n = 0; n < NP; n++) {

    	R0mean += particles[n].R0;
    	rmean += particles[n].r;
    	sigmamean += particles[n].sigma;
    	Sinitmean += particles[n].Sinit;
    	Iinitmean += particles[n].Iinit;
    	Rinitmean += particles[n].Rinit;

    }

    R0mean 		/= NP;
    rmean 		/= NP;
    sigmamean 	/= NP;
    Sinitmean 	/= NP;
    Iinitmean 	/= NP;
    Rinitmean 	/= NP;

    // standard deviations

    float 	R0sd = 0,
    		rsd = 0,
    		sigmasd = 0,
    		Sinitsd = 0,
    		Iinitsd = 0,
    		Rinitsd = 0;

    for (int n = 0; n < NP; n++) {

    	R0sd 	+= ( particles[n].R0 - R0mean ) * ( particles[n].R0 - R0mean );
    	rsd 	+= ( particles[n].r - rmean ) * ( particles[n].r - rmean );
    	sigmasd += ( particles[n].sigma - sigmamean ) * ( particles[n].sigma - sigmamean );
    	Sinitsd += ( particles[n].Sinit - Sinitmean ) * ( particles[n].Sinit - Sinitmean );
    	Iinitsd += ( particles[n].Iinit - Iinitmean ) * ( particles[n].Iinit - Iinitmean );
    	Rinitsd += ( particles[n].Rinit - Rinitmean ) * ( particles[n].Rinit - Rinitmean );

    }

    R0sd 		/= NP;
    rsd 		/= NP;
    sigmasd 	/= NP;
    Sinitsd 	/= NP;
    Iinitsd 	/= NP;
    Rinitsd 	/= NP;

    printf("Parameter estimates (mean | sd)\n");
	printf("-------------------------------\n");
	printf("R0:      %f %f\n", R0mean, R0sd);
	printf("r:       %f %f\n", rmean, rsd);
	printf("sigma:   %f %f\n", sigmamean, sigmasd);
	printf("S_init:  %f %f\n", Sinitmean, Sinitsd);
	printf("I_init:  %f %f\n", Iinitmean, Iinitsd);
	printf("R_init:  %f %f\n", Rinitmean, Rinitsd);


	// Save paramenter distribution results for post-processing

	std::string paramfile("pfdata.dat");

    printf("Writing parameter results to file '%s'...\n", paramfile.c_str());

	FILE * pfout = fopen(paramfile.c_str(), "w");

	for (int n = 0; n < NP; n++) {
		fprintf(pfout, "%f ", particles[n].R0);
		fprintf(pfout, "%f ", particles[n].r);
		fprintf(pfout, "%f ", particles[n].sigma);
		fprintf(pfout, "%f ", particles[n].Sinit);
		fprintf(pfout, "%f ", particles[n].Iinit);
		fprintf(pfout, "%f\n", particles[n].Rinit);
	}

	fclose(pfout);	

	// Save results for plotting

    std::string datafile("plotdata.dat");

    printf("Writing plotting results to file '%s'...\n", datafile.c_str());

	FILE * paramout = fopen(datafile.c_str(), "w");

	for (int t = 0; t < T; t++) {

		fprintf(paramout, "%d ", t);
		fprintf(paramout, "%f ", y_true[t]);

		if (t < Tlim)
			fprintf(paramout, "%f ", y_noise[t]);
		else
			fprintf(paramout, "%d ", -1);

		fprintf(paramout, "%f\n", y_est[t]);

	}

	fclose(paramout);

	printf("Plotting using gnuplot...\n");
	printf("Press ENTER close plot and continue\n");

	std::string syscall("gnuplot -e \"filename='");
	syscall += datafile;
	syscall += "'\" pf.plg";

	//system( syscall.c_str() );

}


/*	Use the Explicit Euler integration scheme to integrate SIR model forward in time
	float h 	- time step size
	float t0 	- start time
	float tn 	- stop time
	float * y 	- current system state; a three-component vector representing [S I R], susceptible-infected-recovered

	*/
void exp_euler_SIR(float h, float t0, float tn, Particle * particle) {
	
	float t = t0;

	int num_steps = floor( (tn-t0) / h );

	float S = particle->S;
	float I = particle->I;
	float R = particle->R;

	float R0 	= particle->R0;
	float r 	= particle->r;
	float B 	= R0 * r / N;

	for(int i = 0; i < num_steps; i++) {
		// get derivatives
		float dS = - B*S*I;
		float dI = B*S*I - r*I;
		float dR = r*I;
		// step forward by h
		S += h*dS;
		I += h*dI;
		R += h*dR;
	}

	particle->S = S;
	particle->I = I;
	particle->R = R;

}


/*	Particle pertubation function to be run between iterations and passes

	*/
void perturbParticles(Particle * particles, int NP, int passnum) {

	float coolcoef = exp( - (float) passnum/2.0 );

    float spreadR0 	= coolcoef * R0true 		/ 10.0;
    float spreadr 	= coolcoef * rtrue 			/ 10.0;
    float spreadsigma = coolcoef * merr 	/ 10.0;
    float spreadIinit = coolcoef * 5.0 	/ 10.0;

    float R0can, rcan, sigmacan, Iinitcan;

    for (int n = 0; n < NP; n++) {

    	do {
    		R0can = particles[n].R0 + spreadR0*randn();
    	} while (R0can < 0);
    	particles[n].R0 = R0can;

    	do {
    		rcan = particles[n].r + spreadr*randn();
    	} while (rcan < 0);
    	particles[n].r = rcan;

    	do {
    		sigmacan = particles[n].sigma + spreadsigma*randn();
    	} while (sigmacan < 0);
    	particles[n].sigma = sigmacan;

    	do {
    		Iinitcan = particles[n].Iinit + spreadIinit*randn();
    	} while (Iinitcan < 0 || Iinitcan > 500);
    	particles[n].Iinit = Iinitcan;

    	particles[n].Sinit = N - particles[n].Iinit;

    }

}


/*	Convinience function for particle resampling process

	*/
void copyParticle(Particle * dst, Particle * src) {

	dst->R0 	= src->R0;
	dst->r 		= src->r;
	dst->sigma 	= src->sigma;
	dst->S 		= src->S;
	dst->I 		= src->I;
	dst->R 		= src->I;
	dst->Sinit  = src->Sinit;
	dst->Iinit  = src->Iinit;
	dst->Rinit  = src->Rinit;

}


/*	Checks to see if particles are collapsed
	This is done by checking if the standard deviations between the particles' parameter
	values are significantly close to one another. Spread threshold may need to be tuned.

	*/
bool isCollapsed(Particle * particles, int NP) {

	bool retVal;

	float R0mean = 0, rmean = 0, sigmamean = 0, Sinitmean = 0, Iinitmean = 0, Rinitmean = 0;

    // means

    for (int n = 0; n < NP; n++) {

    	R0mean += particles[n].R0;
    	rmean += particles[n].r;
    	sigmamean += particles[n].sigma;
    	Sinitmean += particles[n].Sinit;
    	Iinitmean += particles[n].Iinit;
    	Rinitmean += particles[n].Rinit;

    }

    R0mean 		/= NP;
    rmean 		/= NP;
    sigmamean 	/= NP;
    Sinitmean 	/= NP;
    Iinitmean 	/= NP;
    Rinitmean 	/= NP;

	float 	R0sd = 0, rsd = 0, sigmasd = 0, Sinitsd = 0, Iinitsd = 0, Rinitsd = 0;

    for (int n = 0; n < NP; n++) {

    	R0sd 	+= ( particles[n].R0 - R0mean ) * ( particles[n].R0 - R0mean );
    	rsd 	+= ( particles[n].r - rmean ) * ( particles[n].r - rmean );
    	sigmasd += ( particles[n].sigma - sigmamean ) * ( particles[n].sigma - sigmamean );
    	Sinitsd += ( particles[n].Sinit - Sinitmean ) * ( particles[n].Sinit - Sinitmean );
    	Iinitsd += ( particles[n].Iinit - Iinitmean ) * ( particles[n].Iinit - Iinitmean );
    	Rinitsd += ( particles[n].Rinit - Rinitmean ) * ( particles[n].Rinit - Rinitmean );

    }

    R0sd 		/= NP;
    rsd 		/= NP;
    sigmasd 	/= NP;
    Sinitsd 	/= NP;
    Iinitsd 	/= NP;
    Rinitsd 	/= NP;

    if ( (R0sd + rsd + sigmasd) < 1e-5)
    	retVal = true;
    else
    	retVal = false;

    return retVal;

}