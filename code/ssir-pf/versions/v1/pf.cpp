/*	Runs a particle filter on synthetic noisy data and attempts to
	reconstruct underlying true state at each time step. Note that
	this program uses gnuplot to plot the data, so an x11
	environment must be present.

	Also, the accompanying "pf.plg" file contains the instructions
	gnuplot will use. It must be present in the same directory as
	the executable generated by compiling this file.

	*/

#include <stdio.h> 
#include <math.h>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <string>
#include <iostream>

#include "rand.h"
#include "timer.h"
#include "readdata.h"

#define NP 		13*1024		// number of particles
#define R0 		4.0			// infectiousness
#define r 		2e-1		// recovery rate
#define N 		500 		// population size
#define B 		R0*r/N 		// transmission factor
#define merr 	5  			// expected measurement error
#define eta 	0.5			// Beta drift cooling

#define RMAX    4294967296

struct Particle {
	float S;
	float I;
	float R;
	float Beta;
};

void exp_euler_SIR(float h, float t0, float tn, Particle * particles, int pID);

using namespace std;

int main(int argc, char *argv[]) {

	int xdim, ydim;

	if (argc < 3) {
		cout << "Not enough arguments" << endl;
		return 0;
	}

	string arg1(argv[1]);
	string arg2(argv[2]);

	cout << "Arguments:" << endl;
	cout << "    [1] " << arg1 << endl;
	cout << "    [2] " << arg2 << endl;

	int * truevals = getData(arg2, &xdim, &ydim);
	int * datavals = getData(arg1, NULL, NULL);

	int T = ydim / xdim;

	int NUM_BLOCKS = 1;

	float y_true[T];			// true number of infected peeps
	float y_noise[T];			// true number of infected peeps with observation noise
	float y_est[NUM_BLOCKS][T]; // particle mean state estimation

	//float Y[NP][3]; 		// intermediate states
	//float Y_old[NP][3]; 	// intermediate states (temp)
	Particle particles[NP];			// intermediate states
	Particle particles_old[NP];		// intermediate states (temp) 
	float y_par_noise[NP]; 			// particle estimates with noise
	float w[NP]; 					// particle weights

	/*
	float i_infec = 5;
	float y[3] = {N - i_infec, i_infec, 0}; 	// 495 susceptible, 5 infected, 0 recovered

	printf("System parameters\n");
	printf("-----------------\n");
	printf("R0: %f\n", R0);
	printf("r:  %f\n", r);
	printf("B:  %f\n", B);

	*/

	// generate our true trajectory and noisy observation data
	
	/*
	Particle part;
	part.S = N;
	part.I = 1;
	part.R = 0;
	part.Beta = B;

	y_true[0] = part.I;
	y_noise[0] = y_true[0] +  merr*randn();
	if (y_noise[0] < 0)
		y_noise[0] = 0;
	for (int i = 1; i < T; i++) {
		exp_euler_SIR( 1.0/100, 0.0, 1.0, &part, 0);
		y_true[i] = part.I;
		y_noise[i] = y_true[i] + merr*randn();
		if (y_noise[i] < 0)
			y_noise[i] = 0;
	}
	*/

	int cID = 88; // cell number in the range [0,dim*dim] 

	for (int t = 0; t < T; t++) {
		y_true[t] 	= truevals[t*xdim*xdim+cID];
		y_noise[t] 	= datavals[t*xdim*xdim+cID];
	}


	for (int t = 0; t < T; t++)
		cout << y_true[t] << "\t" << y_noise[t] << endl;

	double restime;
	struct timeval  tdr0, tdr1;

	gettimeofday (&tdr0, NULL);

	srand (time(NULL));	   // Seed PRNG with system time


	// DO THE FILTER

	for (int b = 0; b < NUM_BLOCKS; b++) {

		// initialize particle states
		for (int p = 0; p < NP; p++) {

			float i_infec_par = y_noise[0] + merr*randn();
			if (i_infec_par < 0)
				i_infec_par = 0;

			float i_sus_par = N - i_infec_par;

			particles[p].S 		= i_sus_par;
			particles[p].I 		= i_infec_par;
			particles[p].R 		= 0;

			particles[p].Beta 	= 2*B*randu();

		}

		// initial estimate
		y_est[b][0] = 0;
		for (int n = 0; n < NP; n++)
			y_est[b][0] += particles[n].I;
		y_est[b][0] /= NP;

		for (int t = 1; t < T; t++) {

			// can be done completely in parallel
			for (int n = 0; n < NP; n++) {
				exp_euler_SIR(1.0/10, 0.0, 1.0, particles, n); 				// project particles forward
				y_par_noise[n] = particles[n].I + (float) merr*randn();		// perturb with expected measurement noise
				if (y_par_noise[n] < 0)										// make sure we don't go negative
					y_par_noise[n] = 0;
				float y_diff = y_noise[t] - y_par_noise[n];
				w[n] = 1.0/(merr*sqrt(2.0*M_PI)) * exp( - y_diff*y_diff / (2.0*merr*merr) );
			}

			// cumulative sum
			for (int n = 1; n < NP; n++) {
				w[n] += w[n-1];
			}

			for (int n = 0; n < NP; n++) {
				particles_old[n].S 		= particles[n].S;
				particles_old[n].I 		= particles[n].I;
				particles_old[n].R 		= particles[n].R;
				particles_old[n].Beta 	= particles[n].Beta;
			}

			// resampling
			for (int n = 0; n < NP; n++) {

				float w_r = randu() * w[NP-1];
				int i = 0;
				while (w_r >= w[i]) {
					i++;
				}
				// i is now the index to copy state from
				particles[n].S 		= particles_old[i].S;
				particles[n].I 		= particles_old[i].I;
				particles[n].R 		= particles_old[i].R;
				particles[n].Beta 	= particles_old[i].Beta;

			}

			// produce estimate
			y_est[b][t] = 0;
			for (int n = 0; n < NP; n++)
				y_est[b][t] += particles[n].I;
			y_est[b][t] /= NP;	

		}

	}

	gettimeofday (&tdr1, NULL);
    timeval_subtract (&restime, &tdr1, &tdr0);
    printf ("Single threaded runtime %e\n", restime);

    float y_final_est[T];
    for (int t = 0; t < T; t++) {
    	y_final_est[t] = 0;
    	for (int b = 0; b < NUM_BLOCKS; b++)
    		y_final_est[t] += y_est[b][t];
    	y_final_est[t] /= NUM_BLOCKS;
    }

    std::string filename("pf.dat");

    printf("Writing results to file '%s'...\n", filename.c_str());

	FILE * out = fopen(filename.c_str(), "w");

	for (int t = 0; t < T; t++) {
		fprintf(out, "%d ", t);
		fprintf(out, "%f ", y_true[t]);
		fprintf(out, "%f ", y_noise[t]);
		fprintf(out, "%f\n", y_final_est[t]);
	}

	fclose(out);

	printf("Plotting using gnuplot...\n");
	printf("Press ENTER close plot and continue\n");

	std::string syscall("gnuplot -e \"filename='");
	syscall += filename;
	syscall += "'\" pf.plg";

	system( syscall.c_str() );

}


/*	Use the Explicit Euler integration scheme to integrate SIR model forward in time
	float h 	- time step size
	float t0 	- start time
	float tn 	- stop time
	float * y 	- current system state; a three-component vector representing [S I R], susceptible-infected-recovered
	*/
void exp_euler_SIR(float h, float t0, float tn, Particle * particles, int pID) {
	
	float t = t0;

	int num_steps = floor( (tn-t0) / h );

	float S = particles[pID].S;
	float I = particles[pID].I;
	float R = particles[pID].R;
	float Beta = particles[pID].Beta;

	// let Beta walk by about 10% of its value at a time, don't let it go negative
	Beta += (Beta/10.0)*randn();
	if (Beta < 0)
		Beta = 0;

	for(int i = 0; i < num_steps; i++) {
		// get derivatives
		float dS = - Beta*S*I;
		float dI = Beta*S*I - r*I;
		float dR = r*I;
		// step forward by h
		S += h*dS;
		I += h*dI;
		R += h*dR;
	}

	particles[pID].S = S;
	particles[pID].I = I;
	particles[pID].R = R;
	particles[pID].Beta = Beta;

}