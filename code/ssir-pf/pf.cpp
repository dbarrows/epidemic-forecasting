/*	Runs a particle filter on synthetic noisy data and attempts to
	reconstruct underlying true state at each time step. Note that
	this program uses gnuplot to plot the data, so an x11
	environment must be present.

	Also, the accompanying "pf.plg" file contains the instructions
	gnuplot will use. It must be present in the same directory as
	the executable generated by compiling this file.

	*/

#include <stdio.h> 
#include <math.h>
#include <sys/time.h>
#include <time.h>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <sstream>

#include "rand.h"
#include "timer.h"
#include "readdata.h"

#define NP 		5*1024		// number of particles per cell
#define R0 		5.0			// infectiousness
#define r 		2e-1		// recovery rate
#define N 		500 		// population size
#define B 		R0*r/N 		// transmission factor
#define merr 	5  			// expected measurement error
#define eta 	0.5			// Beta drift cooling
#define alp		1e-2		// neighbor effect strength

#define RMAX    4294967296

struct Particle {
	float S;
	float I;
	float R;
	float Beta;
};

void exp_euler_SIR(float h, float t0, float tn,
					Particle * particles, int pID,
					float * I_last, float * Beta_last, int adjMat[][8], int * nNeibVec, int cID);

std::string getHRmemsize (size_t memsize);
std::string getHRtime (double runtime);

using namespace std;

int main(int argc, char *argv[]) {

	int dim, ydim;

	if (argc < 3) {
		cout << "Not enough arguments" << endl;
		return 0;
	}

	string arg1(argv[1]);
	string arg2(argv[2]);

	cout << "Arguments:" << endl;
	cout << "    [1] " << arg1 << endl;
	cout << "    [2] " << arg2 << endl;

	cout << "Getting data" << endl;

	int * truevals = getData(arg2, &dim, &ydim);
	int * datavals = getData(arg1, NULL, NULL);

	cout << "Allocating storage" << endl;

	int T = ydim / dim;
	int nCells = dim*dim;

	float y_true[T];			// true number of infected peeps
	float y_noise[T];			// true number of infected peeps with observation noise

	float y_est[nCells][T]; 	// particle mean state estimation for each cell at each time

	Particle particles[nCells][NP];			// intermediate states
	Particle particles_old[NP];		// intermediate states (temp) 
	float y_par_noise[NP]; 			// particle estimates with noise
	float w[NP]; 					// particle weights

	float y_est_last[nCells];	// storage of Infected estimate between iterations
	float B_est_last[nCells];	// storage of Beta estimate between iterations

	cout << "Populating adjacentcy matrix" << endl;

	// populate adjacentcy matrix **************************************************************************

	int adjMat[nCells][8];		// Each row holds the indices of that cell's neighbours
	int inds_check[8] 	= {-(dim+1), -(dim), -(dim-1), -1, 1, (dim-1), (dim), (dim+1)};
	int nNeibVec[nCells];

	for (int cell = 0; cell < nCells; cell++) {

		int neibCtr = 0;

		int i_cell = cell / dim;
		int j_cell = cell % dim;

		for (int j = 0; j < 8; j++) {

			int nei_ind = cell + inds_check[j];
			int i_ref = nei_ind / dim;
			int j_ref = nei_ind % dim;

			if (0 <= nei_ind && nei_ind < nCells && abs(i_cell - i_ref) <= 1 && abs(j_cell - j_ref) <= 1 ) {
				adjMat[cell][neibCtr] = nei_ind;
				neibCtr++;
			}

			if (neibCtr < 8) {
				for (int i = neibCtr; i < 8; i++)
					adjMat[cell][i] = -1;
			}

		}

		nNeibVec[cell] = neibCtr;

	}

	// *****************************************************************************************************

	double restime;
	struct timeval  tdr0, tdr1;

	gettimeofday (&tdr0, NULL);

	srand (time(NULL));	   // Seed PRNG with system time


	// DO THE FILTER

	cout << "Initializing particles" << endl;

	// initialize particle states
	for (int cell = 0; cell < nCells; cell++) {

		float data = datavals[cell];

		for (int p = 0; p < NP; p++) {

			float i_infec_par = data + merr*randn();
			if (i_infec_par < 0)
				i_infec_par = 0;

			float i_sus_par = N - i_infec_par;

			particles[cell][p].S 		= i_sus_par;
			particles[cell][p].I 		= i_infec_par;
			particles[cell][p].R 		= 0;
			particles[cell][p].Beta 	= 2*B*randu();

		}

	}

	cout << "Generating initial estimate" << endl;

	// initial estimate
	for (int cell = 0; cell < nCells; cell++) {

		y_est[cell][0] = 0;

		for (int n = 0; n < NP; n++)
			y_est[cell][0] += particles[cell][n].I;

		y_est[cell][0] /= NP;

	}

	cout << "Filtering over [1," << T << "]"<< endl;

	// step through time using PF iterations

	int cell;

	for (int t = 1; t < T; t++) {

		for (cell = 0; cell < nCells; cell++) {

			float data = datavals[nCells*t + cell];

			// can be done completely in parallel
			for (int n = 0; n < NP; n++) {

				// "&particles[cell][0]" should be the the row of particles corresponding to this cell
				exp_euler_SIR(1.0/10, 0.0, 1.0, &particles[cell][0], n, y_est_last, B_est_last, adjMat, nNeibVec, cell);

				y_par_noise[n] = particles[cell][n].I + (float) merr*randn();		// perturb with expected measurement noise

				if (y_par_noise[n] < 0)												// make sure we don't go negative
					y_par_noise[n] = 0;

				float y_diff = data - y_par_noise[n];
				w[n] = 1.0/(merr*sqrt(2.0*M_PI)) * exp( - y_diff*y_diff / (2.0*merr*merr) );

			}

			// cumulative sum
			for (int n = 1; n < NP; n++) {
				w[n] += w[n-1];
			}

			for (int n = 0; n < NP; n++) {
				particles_old[n].S 		= particles[cell][n].S;
				particles_old[n].I 		= particles[cell][n].I;
				particles_old[n].R 		= particles[cell][n].R;
				particles_old[n].Beta 	= particles[cell][n].Beta;
			}

			// resampling
			for (int n = 0; n < NP; n++) {

				float w_r = randu() * w[NP-1];
				int i = 0;
				while (w_r >= w[i]) {
					i++;
				}
				// i is now the index to copy state from
				particles[cell][n].S 		= particles_old[i].S;
				particles[cell][n].I 		= particles_old[i].I;
				particles[cell][n].R 		= particles_old[i].R;
				particles[cell][n].Beta 	= particles_old[i].Beta;

			}

			// produce estimate
			y_est[cell][t] = 0;
			for (int n = 0; n < NP; n++)
				y_est[cell][t] += particles[cell][n].I;
			y_est[cell][t] /= NP;

			y_est_last[cell] = y_est[cell][t];

			B_est_last[cell] = 0;
			for (int n = 0; n < NP; n++)
				B_est_last[cell] += particles[cell][n].Beta;
			B_est_last[cell] /= NP;	

		}

		if (t == 1) {
			gettimeofday (&tdr1, NULL);
    		timeval_subtract (&restime, &tdr1, &tdr0);
    		cout << "First iteration completed, about " << getHRtime( restime*((double) T/t - 1.0) ) << " remaining" << endl;
		}

		if ( t%(T/10) == 0 ) {
			gettimeofday (&tdr1, NULL);
    		timeval_subtract (&restime, &tdr1, &tdr0);
			cout << (float) t/T * 100.0 << "%";
			cout << "\t  about " << getHRtime( restime*((double) T/t - 1.0) ) << " remaining" << endl;
		}

	}

	gettimeofday (&tdr1, NULL);
    timeval_subtract (&restime, &tdr1, &tdr0);
    printf ("Single threaded runtime %e\n", restime);


    int cID = 45;

    float y_final_est[T];
    for (int t = 0; t < T; t++) {
    	y_final_est[t] = y_est[cID][t];
    	y_true[t] = truevals[t*nCells + cID];
    	y_noise[t] = datavals[t*nCells + cID];
    }

    std::string filename("pf.dat");

    printf("Writing results to file '%s'...\n", filename.c_str());

	FILE * out = fopen(filename.c_str(), "w");

	for (int t = 0; t < T; t++) {
		fprintf(out, "%d ", t);
		fprintf(out, "%f ", y_true[t]);
		fprintf(out, "%f ", y_noise[t]);
		fprintf(out, "%f\n", y_final_est[t]);
	}

	fclose(out);

	printf("Plotting using gnuplot...\n");
	printf("Press ENTER close plot and continue\n");

	std::string syscall("gnuplot -e \"filename='");
	syscall += filename;
	syscall += "'\" pf.plg";

	cout << syscall << endl;

	system( syscall.c_str() );

}


/*	Use the Explicit Euler integration scheme to integrate SIR model forward in time
	float h 	- time step size
	float t0 	- start time
	float tn 	- stop time
	float * y 	- current system state; a three-component vector representing [S I R], susceptible-infected-recovered
	*/
void exp_euler_SIR(float h, float t0, float tn,
					Particle * particles, int pID,
					float * I_last, float * Beta_last, int adjMat[][8], int * nNeibVec, int cID) {
	
	float t = t0;

	int num_steps = floor( (tn-t0) / h );

	float S = particles[pID].S;
	float I = particles[pID].I;
	float R = particles[pID].R;
	float Beta = particles[pID].Beta;

	int nNei = nNeibVec[cID];

	float nInfec_sum = 0;
	for (int n = 0; n < nNei; n++) {
		int nID = adjMat[cID][n];
		nInfec_sum += Beta_last[nID] * I_last[nID];
	}

	// let Beta walk by about 10% of its value at a time, don't let it go negative
	Beta += (Beta/10.0)*randn();
	if (Beta < 0)
		Beta = 0;

	for(int i = 0; i < num_steps; i++) {
		// get derivatives
		float dS = - (1-nNei*alp)*Beta*S*I - alp*S*nInfec_sum;
		float dI = - dS - r*I;
		float dR = r*I;
		// step forward by h
		S += h*dS;
		I += h*dI;
		R += h*dR;
	}

	particles[pID].S = S;
	particles[pID].I = I;
	particles[pID].R = R;
	particles[pID].Beta = Beta;

}

/*	Convert memory size in bytes to human-readable format
	*/
std::string getHRmemsize (size_t memsize) {

	stringstream ss;
	string valstring;

	int kb = 1024;
	int mb = kb*1024;
	int gb = mb*1024;
	
	if (memsize <= kb)
		ss << memsize << " B";
	else if (memsize > kb && memsize <= mb)
		ss << (float) memsize/ kb << " KB";
	else if (memsize > mb && memsize <= gb)
		ss << (float) memsize/ mb << " MB";
	else
		ss << (float) memsize/ gb << " GB";

	valstring = ss.str();
	
	return valstring;

}


/*	Convert time in seconds to human readable format
	*/
std::string getHRtime (double runtime) {

	stringstream ss;
	string valstring;

	int mt = 60;
	int ht = mt*60;
	int dt = ht*24;
	
	if (runtime <= mt)
		ss << runtime << " s";
	else if (runtime > mt && runtime <= ht)
		ss << runtime/mt << " m";
	else if (runtime > ht && runtime <= dt)
		ss << runtime/ht << " h";
	else
		ss << runtime/dt << " d";

	valstring = ss.str();
	
	return valstring;

}