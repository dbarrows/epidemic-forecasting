I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
StocSIR <- function(y, pars, T, steps) {
out <- matrix(NA, nrow = (T+1), ncol = 4)
R0 <- pars[['R0']]
r <- pars[['r']]
N <- pars[['N']]
eta <- pars[['eta']]
berr <- pars[['berr']]
S <- y[['S']]
I <- y[['I']]
R <- y[['R']]
B0 <- R0 * r / N
B <- B0
out[1,] <- c(S,I,R,B)
h <- 1 / steps
for ( i in 1:(T*steps) ) {
B <- exp( log(B) + eta*(log(B0) - log(B)) + rnorm(1, 0, berr) )
BSI <- B*S*I
rI <- r*I
dS <- -BSI
dI <- BSI - rI
dR <- rI
S <- S + h*dS  #newInf
I <- I + h*dI  #newInf - h*dR
R <- R + h*dR  #h*dR
if (i %% steps == 0)
out[i/steps+1,] <- c(S,I,R,B)
}
return(out)
}
T 		<- 60
i_infec <- 5
steps 	<- 7
N 		<- 500
sigma 	<- 10
Tlim 	<- T
## Generate true trajecory and synthetic data
##
pars_true <- c(R0 = 3.0, 	# new infected people per infected person
r = 0.1, 		# recovery rate
N = 500, 		# population size
eta = 0.5, 	# geometric random walk
berr = 0.5) 	# Beta geometric walk noise
true_init_cond <- c(S = N - i_infec,
I = i_infec,
R = 0)
sdeout_true <- StocSIR(true_init_cond, pars_true, T, steps)
colnames(sdeout_true) <- c('S','I','R','B')
infec_counts_raw <- sdeout_true[,'I'] + rnorm(T+1, 0, sigma)
infec_counts     <- ifelse(infec_counts_raw < 0, 0, infec_counts_raw)
datapart <- c(infec_counts[1:(Tlim+1)],rep(NA,T-Tlim))
qplot(1:(T+1), sdeout_true[,'I'], geom = "line", xlab = "Time", ylab = "Infection count") +
geom_point(aes(y = datapart)) +
theme_bw()
paste("log(",SSE[norm],")")
paste("log(SSE",[norm],")")
setwd("~/Drive/McMaster/Current/Thesis/writing/stochastic-comparison")
source('~/.active-rstudio-document', echo=TRUE)
