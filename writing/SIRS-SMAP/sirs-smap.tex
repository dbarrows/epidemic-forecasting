\documentclass[12pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{multicol}
\usepackage[toc,page]{appendix}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{lstbayes}

\usepackage[usenames,dvipsnames]{color}
\definecolor{DGrey}{gray}{0.25}
\definecolor{MGrey}{gray}{0.50}
\definecolor{LGrey}{gray}{0.75}

\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{Gray}{#1}}
\SetCommentSty{mycommfont}

\usepackage{inconsolata}

\usepackage[parfill]{parskip}
\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}

\newcommand{\et}{e^{i\theta}}
\newcommand{\oo}{\mathcal{O}}
\newcommand{\skipline}{\bigskip\bigskip\bigskip}

\lstdefinestyle{Rsty} { 
    language=R,                         % the language of the code
    basicstyle=\footnotesize\ttfamily,  % the size of the fonts that are used for the code
    numbers=left,                       % where to put the line-numbers
    numberstyle=\footnotesize\color{LGrey},      % the style that is used for the line-numbers
    stepnumber=1,                       % the step between two line-numbers. If it is 1, each line
                                        % will be numbered
    numbersep=5pt,                      % how far the line-numbers are from the code
    backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
    showspaces=false,                   % show spaces adding particular underscores
    showstringspaces=false,             % underline spaces within strings
    showtabs=false,                     % show tabs within strings adding particular underscores
    frame=single,                       % adds a frame around the code
    rulecolor=\color{black},            % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
    tabsize=2,                          % sets default tabsize to 2 spaces
    captionpos=b,                       % sets the caption-position to bottom
    breaklines=true,                    % sets automatic line breaking
    breakatwhitespace=false,            % sets if automatic breaks should only happen at whitespace
    keywordstyle=\color{DGrey},     % keyword style
    commentstyle=\color{LGrey},   % comment style
    stringstyle=\color{MGrey},    % string literal style
    literate={<-}{{$\gets$}}1,           % prettier assignment arrows
    xleftmargin=4.0ex,
    deletekeywords={I,density,rect,_,palette,data,scale,panel,R,frame,labels,options}
}

\lstnewenvironment{R}
{\lstset{style=Rsty}}
{}

\lstdefinestyle{Cppsty} { 
    language=C++,                         % the language of the code
    basicstyle=\footnotesize\ttfamily,  % the size of the fonts that are used for the code
    numbers=left,                       % where to put the line-numbers
    numberstyle=\footnotesize\color{LGrey},      % the style that is used for the line-numbers
    stepnumber=1,                       % the step between two line-numbers. If it is 1, each line
                                        % will be numbered
    numbersep=5pt,                      % how far the line-numbers are from the code
    backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
    showspaces=false,                   % show spaces adding particular underscores
    showstringspaces=false,             % underline spaces within strings
    showtabs=false,                     % show tabs within strings adding particular underscores
    frame=single,                       % adds a frame around the code
    rulecolor=\color{black},            % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
    tabsize=4,                          % sets default tabsize to 2 spaces
    captionpos=b,                       % sets the caption-position to bottom
    breaklines=true,                    % sets automatic line breaking
    breakatwhitespace=false,            % sets if automatic breaks should only happen at whitespace
    keywordstyle=\color{DGrey},     % keyword style
    commentstyle=\color{LGrey},   % comment style
    stringstyle=\color{MGrey},    % string literal style
    %literate={<-}{{$\gets$}}1,           % prettier assignment arrows
    xleftmargin=4.0ex,
    deletekeywords={T}
}

\lstnewenvironment{CPP}
{\lstset{style=Cppsty}}
{}

\lstdefinestyle{Stansty} { 
    language=Stan,                         % the language of the code
    basicstyle=\footnotesize\ttfamily,  % the size of the fonts that are used for the code
    numbers=left,                       % where to put the line-numbers
    numberstyle=\footnotesize\color{LGrey},      % the style that is used for the line-numbers
    stepnumber=1,                       % the step between two line-numbers. If it is 1, each line
                                        % will be numbered
    numbersep=5pt,                      % how far the line-numbers are from the code
    backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
    showspaces=false,                   % show spaces adding particular underscores
    showstringspaces=false,             % underline spaces within strings
    showtabs=false,                     % show tabs within strings adding particular underscores
    frame=single,                       % adds a frame around the code
    rulecolor=\color{black},            % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
    tabsize=2,                          % sets default tabsize to 2 spaces
    captionpos=b,                       % sets the caption-position to bottom
    breaklines=true,                    % sets automatic line breaking
    breakatwhitespace=false,            % sets if automatic breaks should only happen at whitespace
    keywordstyle=\color{DGrey},     % keyword style
    commentstyle=\color{LGrey},   % comment style
    stringstyle=\color{MGrey},    % string literal style
    %literate={<-}{{$\gets$}}1,           % prettier assignment arrows
    xleftmargin=4.0ex,
    deletekeywords={T}
}

\lstnewenvironment{Stan}
{\lstset{style=Stansty}}
{}

\renewcommand{\arraystretch}{2}

\begin{document}

\noindent
{\LARGE {\bf SMAP and SIRS} }
\\\\
Dexter Barrows\\
\today

\section{S-maps}

    A family of forecasting methods that shy away from the mechanistic model-based approaches outlined in the previous sections have been developed by Sugihara (references) over the last several decades. As these methods do not include a mechanistic model in their forecasting process, they also do not attempt to perform parameter inference. Instead they attempt to reconstruct the underlying dynamical process as a weighted linear model from a time series.

    One such method, the sequential locally weighted global linear maps (S-map), builds a global linear map model and uses it to produce forecasts directly. Despite relying on a linear mapping, the S-map does not assume the time series on which it is operating is the product of linear system dynamics, and in fact was developed to accommodate non-linear dynamics.

    The S-map works by first constructing a time series embedding of length $E$, known as the library and denoted $\{\mathbf{x_i}\}$. Consider a time series of length $T$ denoted $x_1, x_2,..., x_T$. Each element in the time series with indices in the range $E,E+1,...,T$ will have a corresponding entry in the library such that a given element $x_t$ will correspond to a library vector of the form $\mathbf{x_i} = (x_t, x_{t-1},...,x_{t-E+1})$. Next, given a forecast length $L$ (representing $L$ time steps into the future), each library vector $\mathbf{x_i}$ is assigned a prediction from the time series $y_i = x_{t+L}$, where $x_t$ is the first entry in $\mathbf{x_i}$. Finally, a forecast ${\hat{y_t}}$ for specified predictor vector $\mathbf{x_t}$ (usually from the library itself), is generated using an exponentially weighted function of the library $\{\mathbf{x_i}\}$, predictions $\{y_i\}$, and predictor vector $\mathbf{x_t}$.

    This function is defined as follows:

    First construct a matrix $A$ and vector $b$ defined as

    \begin{equation}\label{AB}
    	\begin{array}{rl}
        \displaystyle
            A(i, j) & = w (||\mathbf{x_i}-\mathbf{x_t}||) \mathbf{x_i}(j) \\
            b(i) 	& = w (||\mathbf{x_i}-\mathbf{x_t}||) y_i
        \end{array}
    \end{equation}

    where $i$ ranges over 1 to the length of the library, and $j$ ranges over $[0,E]$. It should be noted that in the above equations and the ones that follow, $x_t(0) = 1$ to account for the linear term in the map.

	The weighting function $w$ is defined as

	\begin{equation}
		w(d) = \exp \left( \frac{-\theta d}{\bar{d}} \right) ,
	\end{equation}

	where $d$ is the euclidean distance between the predictor vector and library vectors in Equation (\ref{AB}) and $\bar{d}$ is the average of these distances. We can then see that $\theta$ serves as a way to specify the appropriate level of penalization applied to poorly-matching library vectors -- if $\theta$ is 0 all weights are the same (no penalization), and increasing $\theta$ increases the level of penalization.

	Now we solve the system $Ac = b$ to obtain the linear weightings used in to generate the forecast according to

	\begin{equation}
		\hat{y_t} = \sum_{j = 0}^{E} c_t(j) \mathbf{x_t}(j) .
	\end{equation}

	In this way we have produced a forecast value for a single time. This process can be repeated for a sequence of times $T + 1, T + 2, ...$ to project a time series into the future.


\section{S-map Algorithm}

    The above description can be summarized in algorithm

    \begin{algorithm}[H]

        \BlankLine

        \SetKwInOut{Input}{Input}
        \SetKwInOut{Output}{Output}
        \DontPrintSemicolon

        \tcc{Select a starting point}
        \Input{Time series $x_1, x_2, ..., x_T$, embedding dimension $E$, distance penalization $\theta$, forecast length $L$, predictor vector $\mathbf{x_t}$}

        \BlankLine

        \tcc{Construct library}
        \For{$i = E:T$}{
        	$\{{\mathbf{x_i}}\}$, $\mathbf{x_i} = (x_i, x_{i-1}, ...,x_{i-E-1})$
        }

        \BlankLine

        \For{$i = 1:(T_E+1)$}{
	        $b(i) = w(||\mathbf{x_i} - \mathbf{x_t}||) y_i$ \\
        	\For{$j = 1:E$}{
	        	$A(i,j) = w(||\mathbf{x_i} - \mathbf{x_t}||) \mathbf{x_i}(j)$
	        }
        }

        \BlankLine

        \tcc{Use SVD to solve Ac = b}
        $SVD(Ac = b)$

        \BlankLine

        \tcc{Compute forecast}
        $\hat{y_t} = \sum_{j = 0}^{E} c_t (j) \mathbf{x_t} (j)$

        \BlankLine

        \tcc{Forecasted value in time series}
        \Output{Forecast $\hat{y_t}$}

        \BlankLine

        \caption{S-map}\label{smap}

    \end{algorithm}

\section{SIRS Model}

	In an epidemic or infectious disease context, the S-map algorithm will only really work on time series that appear cyclic. While there is nothing mechanically that prevents it from operating on a time series that do not appear cyclic, S-mapping requires a long time series in order to build a quality library. Without one the forecasting process would produce unreliable data.

	With that in mind, the only fair way to compare the efficacy of s-mapping to IF2 or Hamiltonian MCMC is to generate data from a SIRS model with a seasonal component, and have all methods operate on the resulting time series.

	The basic skeleton of the SIRS model is similar to the stochastic SIR model described previously. The deterministic ODE component of the model is as follows.

	\begin{equation}
		\begin{aligned}
			\frac{dS}{dt} & = - \Gamma(t) \beta S I + \eta R \\
			\frac{dI}{dt} & = \Gamma(t) \beta S I - \gamma I \\
			\frac{dR}{dt} & = \gamma I - \eta R,
		\end{aligned}
	\end{equation}

	There are two new features here. We have a re-susceptibility rate $\eta$ through which people become able to be reinfected, and a seasonality factor $\Gamma$ defined as

	\begin{equation}
		\Gamma(t) = \exp \left( 2 cos \left(  \frac{2 \pi}{365} t \right) - 2 \right) .
	\end{equation}

	This function oscillates between 1 and $e^{-4}$ (close to 0) and is meant to represent transmission damping during the off-season, for example summer for influenza. Further, it displays flatter troughs and sharper peaks to exaggerate its effect in peak season.

	As before, $\beta$ is allowed to walk restricted by a geometric mean, described by

	\begin{equation}
		\beta_{t+1} = \exp \left( \log(\beta_{t}) + \eta (\log(\bar{\beta}) - \log(\beta_{t})) + \epsilon_{t} \right).
	\end{equation}

	When simulated for the equivalent of 5 years (260 weeks), and adding noise drawn from $\mathcal{N}(0,\sigma)$we obtain Figure [\ref{dataplot}].

	\begin{figure}[H]
        \centering
        \captionsetup{width=.8\linewidth}
        \includegraphics[width=0.8\textwidth]{./images/dataplot.pdf}
        \caption{Five cycles generated by the SIRS function. The solid line the the true number of cases, dots show case counts with added observation noise. The Parameter values were $R0 = 3.0$, $\gamma = 0.1$, $\eta = 1$, $\sigma = 5$, and 10 initial cases.}
        \label{dataplot}
    \end{figure}

    We can see how the S-map can reconstruct the next cycle in the time series in Figure [\ref{smap_project}].

    \begin{figure}[H]
        \centering
        \captionsetup{width=.8\linewidth}
        \includegraphics[width=0.8\textwidth]{./images/smap-project.pdf}
        \caption{S-map applied to the data from the previous figure. The solid line shows the infection counts with observation noise form the previous plot, and the dotted line is the S-map forecast. Parameters chosen were $E = 14$ and $\theta = 3$.}
        \label{smap_project}
    \end{figure}

    The parameters used in the S-map algorithm to obtain the forecast used in Figure [\ref{smap_project}] were obtained using a grid search of potential parameters outlined in (Sugihara ref). The script is included in the Appendices.


\newpage
\begin{appendices}

	\section{SIRS R Function Code}

		R code to simulate the outlines SIRS function.

		\lstinputlisting[style=Rsty]{../../code/sir-functions/StocSIRS.r}

	\section{SMAP Code}

		This code implements an SMAP function on a user-provided time series.

		\lstinputlisting[style=Rsty]{../../code/smap/smap.r}

	\section{SMAP Parameter Optimization Code}

		This code determines the optimal parameter values to be used by the S-map algorithm.

		\lstinputlisting[style=Rsty]{../../code/smap/smap_opt.r}

	\section{RStan SIRS Code}

	    This code implements a periodic SIRS model in Rstan.

	    \lstinputlisting[style=Rsty]{../../code/hmc/hmc-sirs/sirs-euler.stan}

    \section{IF2 SIRS Code}

	    This code implements a periodic SIRS model using IF2 in C++.

	    \lstinputlisting[style=Cppsty]{../../code/if2/if2-sirs/if2-sirs.cpp}

\end{appendices}



\end{document}